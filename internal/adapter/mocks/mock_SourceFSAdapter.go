// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"

	adapter "gooze.dev/pkg/gooze/internal/adapter"

	fs "io/fs"

	mock "github.com/stretchr/testify/mock"

	model "gooze.dev/pkg/gooze/internal/model"
)

// MockSourceFSAdapter is an autogenerated mock type for the SourceFSAdapter type
type MockSourceFSAdapter struct {
	mock.Mock
}

type MockSourceFSAdapter_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSourceFSAdapter) EXPECT() *MockSourceFSAdapter_Expecter {
	return &MockSourceFSAdapter_Expecter{mock: &_m.Mock}
}

// CopyDir provides a mock function with given fields: ctx, src, dst
func (_m *MockSourceFSAdapter) CopyDir(ctx context.Context, src model.Path, dst model.Path) error {
	ret := _m.Called(ctx, src, dst)

	if len(ret) == 0 {
		panic("no return value specified for CopyDir")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, model.Path, model.Path) error); ok {
		r0 = rf(ctx, src, dst)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSourceFSAdapter_CopyDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CopyDir'
type MockSourceFSAdapter_CopyDir_Call struct {
	*mock.Call
}

// CopyDir is a helper method to define mock.On call
//   - ctx context.Context
//   - src model.Path
//   - dst model.Path
func (_e *MockSourceFSAdapter_Expecter) CopyDir(ctx interface{}, src interface{}, dst interface{}) *MockSourceFSAdapter_CopyDir_Call {
	return &MockSourceFSAdapter_CopyDir_Call{Call: _e.mock.On("CopyDir", ctx, src, dst)}
}

func (_c *MockSourceFSAdapter_CopyDir_Call) Run(run func(ctx context.Context, src model.Path, dst model.Path)) *MockSourceFSAdapter_CopyDir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.Path), args[2].(model.Path))
	})
	return _c
}

func (_c *MockSourceFSAdapter_CopyDir_Call) Return(_a0 error) *MockSourceFSAdapter_CopyDir_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSourceFSAdapter_CopyDir_Call) RunAndReturn(run func(context.Context, model.Path, model.Path) error) *MockSourceFSAdapter_CopyDir_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTempDir provides a mock function with given fields: ctx, pattern
func (_m *MockSourceFSAdapter) CreateTempDir(ctx context.Context, pattern string) (model.Path, error) {
	ret := _m.Called(ctx, pattern)

	if len(ret) == 0 {
		panic("no return value specified for CreateTempDir")
	}

	var r0 model.Path
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (model.Path, error)); ok {
		return rf(ctx, pattern)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) model.Path); ok {
		r0 = rf(ctx, pattern)
	} else {
		r0 = ret.Get(0).(model.Path)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, pattern)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSourceFSAdapter_CreateTempDir_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTempDir'
type MockSourceFSAdapter_CreateTempDir_Call struct {
	*mock.Call
}

// CreateTempDir is a helper method to define mock.On call
//   - ctx context.Context
//   - pattern string
func (_e *MockSourceFSAdapter_Expecter) CreateTempDir(ctx interface{}, pattern interface{}) *MockSourceFSAdapter_CreateTempDir_Call {
	return &MockSourceFSAdapter_CreateTempDir_Call{Call: _e.mock.On("CreateTempDir", ctx, pattern)}
}

func (_c *MockSourceFSAdapter_CreateTempDir_Call) Run(run func(ctx context.Context, pattern string)) *MockSourceFSAdapter_CreateTempDir_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockSourceFSAdapter_CreateTempDir_Call) Return(_a0 model.Path, _a1 error) *MockSourceFSAdapter_CreateTempDir_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSourceFSAdapter_CreateTempDir_Call) RunAndReturn(run func(context.Context, string) (model.Path, error)) *MockSourceFSAdapter_CreateTempDir_Call {
	_c.Call.Return(run)
	return _c
}

// DetectTestFile provides a mock function with given fields: ctx, sourcePath
func (_m *MockSourceFSAdapter) DetectTestFile(ctx context.Context, sourcePath model.Path) (model.Path, error) {
	ret := _m.Called(ctx, sourcePath)

	if len(ret) == 0 {
		panic("no return value specified for DetectTestFile")
	}

	var r0 model.Path
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, model.Path) (model.Path, error)); ok {
		return rf(ctx, sourcePath)
	}
	if rf, ok := ret.Get(0).(func(context.Context, model.Path) model.Path); ok {
		r0 = rf(ctx, sourcePath)
	} else {
		r0 = ret.Get(0).(model.Path)
	}

	if rf, ok := ret.Get(1).(func(context.Context, model.Path) error); ok {
		r1 = rf(ctx, sourcePath)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSourceFSAdapter_DetectTestFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DetectTestFile'
type MockSourceFSAdapter_DetectTestFile_Call struct {
	*mock.Call
}

// DetectTestFile is a helper method to define mock.On call
//   - ctx context.Context
//   - sourcePath model.Path
func (_e *MockSourceFSAdapter_Expecter) DetectTestFile(ctx interface{}, sourcePath interface{}) *MockSourceFSAdapter_DetectTestFile_Call {
	return &MockSourceFSAdapter_DetectTestFile_Call{Call: _e.mock.On("DetectTestFile", ctx, sourcePath)}
}

func (_c *MockSourceFSAdapter_DetectTestFile_Call) Run(run func(ctx context.Context, sourcePath model.Path)) *MockSourceFSAdapter_DetectTestFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.Path))
	})
	return _c
}

func (_c *MockSourceFSAdapter_DetectTestFile_Call) Return(_a0 model.Path, _a1 error) *MockSourceFSAdapter_DetectTestFile_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSourceFSAdapter_DetectTestFile_Call) RunAndReturn(run func(context.Context, model.Path) (model.Path, error)) *MockSourceFSAdapter_DetectTestFile_Call {
	_c.Call.Return(run)
	return _c
}

// FileInfo provides a mock function with given fields: ctx, path
func (_m *MockSourceFSAdapter) FileInfo(ctx context.Context, path model.Path) (fs.FileInfo, error) {
	ret := _m.Called(ctx, path)

	if len(ret) == 0 {
		panic("no return value specified for FileInfo")
	}

	var r0 fs.FileInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, model.Path) (fs.FileInfo, error)); ok {
		return rf(ctx, path)
	}
	if rf, ok := ret.Get(0).(func(context.Context, model.Path) fs.FileInfo); ok {
		r0 = rf(ctx, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(fs.FileInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, model.Path) error); ok {
		r1 = rf(ctx, path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSourceFSAdapter_FileInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FileInfo'
type MockSourceFSAdapter_FileInfo_Call struct {
	*mock.Call
}

// FileInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - path model.Path
func (_e *MockSourceFSAdapter_Expecter) FileInfo(ctx interface{}, path interface{}) *MockSourceFSAdapter_FileInfo_Call {
	return &MockSourceFSAdapter_FileInfo_Call{Call: _e.mock.On("FileInfo", ctx, path)}
}

func (_c *MockSourceFSAdapter_FileInfo_Call) Run(run func(ctx context.Context, path model.Path)) *MockSourceFSAdapter_FileInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.Path))
	})
	return _c
}

func (_c *MockSourceFSAdapter_FileInfo_Call) Return(_a0 fs.FileInfo, _a1 error) *MockSourceFSAdapter_FileInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSourceFSAdapter_FileInfo_Call) RunAndReturn(run func(context.Context, model.Path) (fs.FileInfo, error)) *MockSourceFSAdapter_FileInfo_Call {
	_c.Call.Return(run)
	return _c
}

// FindProjectRoot provides a mock function with given fields: ctx, startPath
func (_m *MockSourceFSAdapter) FindProjectRoot(ctx context.Context, startPath model.Path) (model.Path, error) {
	ret := _m.Called(ctx, startPath)

	if len(ret) == 0 {
		panic("no return value specified for FindProjectRoot")
	}

	var r0 model.Path
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, model.Path) (model.Path, error)); ok {
		return rf(ctx, startPath)
	}
	if rf, ok := ret.Get(0).(func(context.Context, model.Path) model.Path); ok {
		r0 = rf(ctx, startPath)
	} else {
		r0 = ret.Get(0).(model.Path)
	}

	if rf, ok := ret.Get(1).(func(context.Context, model.Path) error); ok {
		r1 = rf(ctx, startPath)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSourceFSAdapter_FindProjectRoot_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindProjectRoot'
type MockSourceFSAdapter_FindProjectRoot_Call struct {
	*mock.Call
}

// FindProjectRoot is a helper method to define mock.On call
//   - ctx context.Context
//   - startPath model.Path
func (_e *MockSourceFSAdapter_Expecter) FindProjectRoot(ctx interface{}, startPath interface{}) *MockSourceFSAdapter_FindProjectRoot_Call {
	return &MockSourceFSAdapter_FindProjectRoot_Call{Call: _e.mock.On("FindProjectRoot", ctx, startPath)}
}

func (_c *MockSourceFSAdapter_FindProjectRoot_Call) Run(run func(ctx context.Context, startPath model.Path)) *MockSourceFSAdapter_FindProjectRoot_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.Path))
	})
	return _c
}

func (_c *MockSourceFSAdapter_FindProjectRoot_Call) Return(_a0 model.Path, _a1 error) *MockSourceFSAdapter_FindProjectRoot_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSourceFSAdapter_FindProjectRoot_Call) RunAndReturn(run func(context.Context, model.Path) (model.Path, error)) *MockSourceFSAdapter_FindProjectRoot_Call {
	_c.Call.Return(run)
	return _c
}

// Get provides a mock function with given fields: ctx, roots, ignore
func (_m *MockSourceFSAdapter) Get(ctx context.Context, roots []model.Path, ignore ...string) ([]model.Source, error) {
	_va := make([]interface{}, len(ignore))
	for _i := range ignore {
		_va[_i] = ignore[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, roots)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 []model.Source
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []model.Path, ...string) ([]model.Source, error)); ok {
		return rf(ctx, roots, ignore...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []model.Path, ...string) []model.Source); ok {
		r0 = rf(ctx, roots, ignore...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.Source)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []model.Path, ...string) error); ok {
		r1 = rf(ctx, roots, ignore...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSourceFSAdapter_Get_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Get'
type MockSourceFSAdapter_Get_Call struct {
	*mock.Call
}

// Get is a helper method to define mock.On call
//   - ctx context.Context
//   - roots []model.Path
//   - ignore ...string
func (_e *MockSourceFSAdapter_Expecter) Get(ctx interface{}, roots interface{}, ignore ...interface{}) *MockSourceFSAdapter_Get_Call {
	return &MockSourceFSAdapter_Get_Call{Call: _e.mock.On("Get",
		append([]interface{}{ctx, roots}, ignore...)...)}
}

func (_c *MockSourceFSAdapter_Get_Call) Run(run func(ctx context.Context, roots []model.Path, ignore ...string)) *MockSourceFSAdapter_Get_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), args[1].([]model.Path), variadicArgs...)
	})
	return _c
}

func (_c *MockSourceFSAdapter_Get_Call) Return(_a0 []model.Source, _a1 error) *MockSourceFSAdapter_Get_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSourceFSAdapter_Get_Call) RunAndReturn(run func(context.Context, []model.Path, ...string) ([]model.Source, error)) *MockSourceFSAdapter_Get_Call {
	_c.Call.Return(run)
	return _c
}

// HashFile provides a mock function with given fields: ctx, path
func (_m *MockSourceFSAdapter) HashFile(ctx context.Context, path model.Path) (string, error) {
	ret := _m.Called(ctx, path)

	if len(ret) == 0 {
		panic("no return value specified for HashFile")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, model.Path) (string, error)); ok {
		return rf(ctx, path)
	}
	if rf, ok := ret.Get(0).(func(context.Context, model.Path) string); ok {
		r0 = rf(ctx, path)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, model.Path) error); ok {
		r1 = rf(ctx, path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSourceFSAdapter_HashFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HashFile'
type MockSourceFSAdapter_HashFile_Call struct {
	*mock.Call
}

// HashFile is a helper method to define mock.On call
//   - ctx context.Context
//   - path model.Path
func (_e *MockSourceFSAdapter_Expecter) HashFile(ctx interface{}, path interface{}) *MockSourceFSAdapter_HashFile_Call {
	return &MockSourceFSAdapter_HashFile_Call{Call: _e.mock.On("HashFile", ctx, path)}
}

func (_c *MockSourceFSAdapter_HashFile_Call) Run(run func(ctx context.Context, path model.Path)) *MockSourceFSAdapter_HashFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.Path))
	})
	return _c
}

func (_c *MockSourceFSAdapter_HashFile_Call) Return(_a0 string, _a1 error) *MockSourceFSAdapter_HashFile_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSourceFSAdapter_HashFile_Call) RunAndReturn(run func(context.Context, model.Path) (string, error)) *MockSourceFSAdapter_HashFile_Call {
	_c.Call.Return(run)
	return _c
}

// JoinPath provides a mock function with given fields: ctx, elem
func (_m *MockSourceFSAdapter) JoinPath(ctx context.Context, elem ...string) model.Path {
	_va := make([]interface{}, len(elem))
	for _i := range elem {
		_va[_i] = elem[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for JoinPath")
	}

	var r0 model.Path
	if rf, ok := ret.Get(0).(func(context.Context, ...string) model.Path); ok {
		r0 = rf(ctx, elem...)
	} else {
		r0 = ret.Get(0).(model.Path)
	}

	return r0
}

// MockSourceFSAdapter_JoinPath_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'JoinPath'
type MockSourceFSAdapter_JoinPath_Call struct {
	*mock.Call
}

// JoinPath is a helper method to define mock.On call
//   - ctx context.Context
//   - elem ...string
func (_e *MockSourceFSAdapter_Expecter) JoinPath(ctx interface{}, elem ...interface{}) *MockSourceFSAdapter_JoinPath_Call {
	return &MockSourceFSAdapter_JoinPath_Call{Call: _e.mock.On("JoinPath",
		append([]interface{}{ctx}, elem...)...)}
}

func (_c *MockSourceFSAdapter_JoinPath_Call) Run(run func(ctx context.Context, elem ...string)) *MockSourceFSAdapter_JoinPath_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]string, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(string)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockSourceFSAdapter_JoinPath_Call) Return(_a0 model.Path) *MockSourceFSAdapter_JoinPath_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSourceFSAdapter_JoinPath_Call) RunAndReturn(run func(context.Context, ...string) model.Path) *MockSourceFSAdapter_JoinPath_Call {
	_c.Call.Return(run)
	return _c
}

// ReadFile provides a mock function with given fields: ctx, path
func (_m *MockSourceFSAdapter) ReadFile(ctx context.Context, path model.Path) ([]byte, error) {
	ret := _m.Called(ctx, path)

	if len(ret) == 0 {
		panic("no return value specified for ReadFile")
	}

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, model.Path) ([]byte, error)); ok {
		return rf(ctx, path)
	}
	if rf, ok := ret.Get(0).(func(context.Context, model.Path) []byte); ok {
		r0 = rf(ctx, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, model.Path) error); ok {
		r1 = rf(ctx, path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSourceFSAdapter_ReadFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReadFile'
type MockSourceFSAdapter_ReadFile_Call struct {
	*mock.Call
}

// ReadFile is a helper method to define mock.On call
//   - ctx context.Context
//   - path model.Path
func (_e *MockSourceFSAdapter_Expecter) ReadFile(ctx interface{}, path interface{}) *MockSourceFSAdapter_ReadFile_Call {
	return &MockSourceFSAdapter_ReadFile_Call{Call: _e.mock.On("ReadFile", ctx, path)}
}

func (_c *MockSourceFSAdapter_ReadFile_Call) Run(run func(ctx context.Context, path model.Path)) *MockSourceFSAdapter_ReadFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.Path))
	})
	return _c
}

func (_c *MockSourceFSAdapter_ReadFile_Call) Return(_a0 []byte, _a1 error) *MockSourceFSAdapter_ReadFile_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSourceFSAdapter_ReadFile_Call) RunAndReturn(run func(context.Context, model.Path) ([]byte, error)) *MockSourceFSAdapter_ReadFile_Call {
	_c.Call.Return(run)
	return _c
}

// RelPath provides a mock function with given fields: ctx, base, target
func (_m *MockSourceFSAdapter) RelPath(ctx context.Context, base model.Path, target model.Path) (model.Path, error) {
	ret := _m.Called(ctx, base, target)

	if len(ret) == 0 {
		panic("no return value specified for RelPath")
	}

	var r0 model.Path
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, model.Path, model.Path) (model.Path, error)); ok {
		return rf(ctx, base, target)
	}
	if rf, ok := ret.Get(0).(func(context.Context, model.Path, model.Path) model.Path); ok {
		r0 = rf(ctx, base, target)
	} else {
		r0 = ret.Get(0).(model.Path)
	}

	if rf, ok := ret.Get(1).(func(context.Context, model.Path, model.Path) error); ok {
		r1 = rf(ctx, base, target)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockSourceFSAdapter_RelPath_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RelPath'
type MockSourceFSAdapter_RelPath_Call struct {
	*mock.Call
}

// RelPath is a helper method to define mock.On call
//   - ctx context.Context
//   - base model.Path
//   - target model.Path
func (_e *MockSourceFSAdapter_Expecter) RelPath(ctx interface{}, base interface{}, target interface{}) *MockSourceFSAdapter_RelPath_Call {
	return &MockSourceFSAdapter_RelPath_Call{Call: _e.mock.On("RelPath", ctx, base, target)}
}

func (_c *MockSourceFSAdapter_RelPath_Call) Run(run func(ctx context.Context, base model.Path, target model.Path)) *MockSourceFSAdapter_RelPath_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.Path), args[2].(model.Path))
	})
	return _c
}

func (_c *MockSourceFSAdapter_RelPath_Call) Return(_a0 model.Path, _a1 error) *MockSourceFSAdapter_RelPath_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockSourceFSAdapter_RelPath_Call) RunAndReturn(run func(context.Context, model.Path, model.Path) (model.Path, error)) *MockSourceFSAdapter_RelPath_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveAll provides a mock function with given fields: ctx, path
func (_m *MockSourceFSAdapter) RemoveAll(ctx context.Context, path model.Path) error {
	ret := _m.Called(ctx, path)

	if len(ret) == 0 {
		panic("no return value specified for RemoveAll")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, model.Path) error); ok {
		r0 = rf(ctx, path)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSourceFSAdapter_RemoveAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveAll'
type MockSourceFSAdapter_RemoveAll_Call struct {
	*mock.Call
}

// RemoveAll is a helper method to define mock.On call
//   - ctx context.Context
//   - path model.Path
func (_e *MockSourceFSAdapter_Expecter) RemoveAll(ctx interface{}, path interface{}) *MockSourceFSAdapter_RemoveAll_Call {
	return &MockSourceFSAdapter_RemoveAll_Call{Call: _e.mock.On("RemoveAll", ctx, path)}
}

func (_c *MockSourceFSAdapter_RemoveAll_Call) Run(run func(ctx context.Context, path model.Path)) *MockSourceFSAdapter_RemoveAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.Path))
	})
	return _c
}

func (_c *MockSourceFSAdapter_RemoveAll_Call) Return(_a0 error) *MockSourceFSAdapter_RemoveAll_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSourceFSAdapter_RemoveAll_Call) RunAndReturn(run func(context.Context, model.Path) error) *MockSourceFSAdapter_RemoveAll_Call {
	_c.Call.Return(run)
	return _c
}

// Walk provides a mock function with given fields: ctx, root, recursive, fn
func (_m *MockSourceFSAdapter) Walk(ctx context.Context, root model.Path, recursive bool, fn adapter.FilepathWalkFunc) error {
	ret := _m.Called(ctx, root, recursive, fn)

	if len(ret) == 0 {
		panic("no return value specified for Walk")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, model.Path, bool, adapter.FilepathWalkFunc) error); ok {
		r0 = rf(ctx, root, recursive, fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSourceFSAdapter_Walk_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Walk'
type MockSourceFSAdapter_Walk_Call struct {
	*mock.Call
}

// Walk is a helper method to define mock.On call
//   - ctx context.Context
//   - root model.Path
//   - recursive bool
//   - fn adapter.FilepathWalkFunc
func (_e *MockSourceFSAdapter_Expecter) Walk(ctx interface{}, root interface{}, recursive interface{}, fn interface{}) *MockSourceFSAdapter_Walk_Call {
	return &MockSourceFSAdapter_Walk_Call{Call: _e.mock.On("Walk", ctx, root, recursive, fn)}
}

func (_c *MockSourceFSAdapter_Walk_Call) Run(run func(ctx context.Context, root model.Path, recursive bool, fn adapter.FilepathWalkFunc)) *MockSourceFSAdapter_Walk_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.Path), args[2].(bool), args[3].(adapter.FilepathWalkFunc))
	})
	return _c
}

func (_c *MockSourceFSAdapter_Walk_Call) Return(_a0 error) *MockSourceFSAdapter_Walk_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSourceFSAdapter_Walk_Call) RunAndReturn(run func(context.Context, model.Path, bool, adapter.FilepathWalkFunc) error) *MockSourceFSAdapter_Walk_Call {
	_c.Call.Return(run)
	return _c
}

// WriteFile provides a mock function with given fields: ctx, path, content, perm
func (_m *MockSourceFSAdapter) WriteFile(ctx context.Context, path model.Path, content []byte, perm fs.FileMode) error {
	ret := _m.Called(ctx, path, content, perm)

	if len(ret) == 0 {
		panic("no return value specified for WriteFile")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, model.Path, []byte, fs.FileMode) error); ok {
		r0 = rf(ctx, path, content, perm)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockSourceFSAdapter_WriteFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WriteFile'
type MockSourceFSAdapter_WriteFile_Call struct {
	*mock.Call
}

// WriteFile is a helper method to define mock.On call
//   - ctx context.Context
//   - path model.Path
//   - content []byte
//   - perm fs.FileMode
func (_e *MockSourceFSAdapter_Expecter) WriteFile(ctx interface{}, path interface{}, content interface{}, perm interface{}) *MockSourceFSAdapter_WriteFile_Call {
	return &MockSourceFSAdapter_WriteFile_Call{Call: _e.mock.On("WriteFile", ctx, path, content, perm)}
}

func (_c *MockSourceFSAdapter_WriteFile_Call) Run(run func(ctx context.Context, path model.Path, content []byte, perm fs.FileMode)) *MockSourceFSAdapter_WriteFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.Path), args[2].([]byte), args[3].(fs.FileMode))
	})
	return _c
}

func (_c *MockSourceFSAdapter_WriteFile_Call) Return(_a0 error) *MockSourceFSAdapter_WriteFile_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockSourceFSAdapter_WriteFile_Call) RunAndReturn(run func(context.Context, model.Path, []byte, fs.FileMode) error) *MockSourceFSAdapter_WriteFile_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSourceFSAdapter creates a new instance of MockSourceFSAdapter. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSourceFSAdapter(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSourceFSAdapter {
	mock := &MockSourceFSAdapter{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
